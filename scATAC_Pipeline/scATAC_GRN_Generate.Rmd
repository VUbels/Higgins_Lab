---
title: "scATAC_GRN_Generate"
author: "Victor Ubels"
date: "2024-10-15"
output: html_document
---

```{r}
# renv::init()
# 
# if (!requireNamespace("devtools", quietly = TRUE)) install.packages("devtools")
# if (!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager")
# 
# install.packages(c("remotes", "nloptr", "reticulate", "ggridges", "Seurat", "harmony"))
# library(remotes)
# install_version("ggplot2", version = "3.4.0", repos = "http://cran.us.r-project.org")
# 
# ##DO NOT CHANGE GGPLOT2 VERSION UPDATING TO >3.4.0 BRICKS ARCHR PLOT FUNCTION##
# 
# BiocManager::install(c("DirichletMultinomial", "TFBSTools", "Gviz", "GenomicRanges", "rtracklayer", 'BiocGenerics', 'DelayedArray', 'DelayedMatrixStats', 'limma', 'lme4', 'S4Vectors', 'SingleCellExperiment', 'SummarizedExperiment', 'batchelor', 'HDF5Array', 'terra', 'ggrastr'))
# 
# devtools::install_github("GreenleafLab/ArchR", ref="master", repos = BiocManager::repositories())
# devtools::install_github('cole-trapnell-lab/monocle3')
# devtools::install_github("cole-trapnell-lab/cicero-release", ref = "monocle3")
```

```{r}
library(ArchR)
library(cicero)
library(monocle3)
library(reticulate)
library(renv)
library(Seurat)
library(harmony)

getwd()
renv::status()

PY_PATH <- "/home/uvictor/higgins_lab/scATAC_Pipeline/renv/python/virtualenvs/renv-python-3.11/bin/python3.11"
Sys.setenv(RETICULATE_PYTHON = PY_PATH)
reticulate::use_python(PY_PATH, required = TRUE)

file.exists(".Rprofile")

#reticulate::py_install("numpy")
#reticulate::py_install("MACS2")

addArchRThreads(threads = 1)
pathToMacs2 <- findMacs2()
```
```{r}
addArchRGenome("hg38")
outputFolder = "/mnt/d/scATAC_output/Greenleaf_23"
```

```{r}
fragmentFiles <- list.files("/mnt/d/scATAC_Input/Greenleaf_23", pattern = ".tsv.gz$", full.names = TRUE)

# Extract sample names from file names
sampleNames <- tools::file_path_sans_ext(basename(fragmentFiles))
sampleNames <- tools::file_path_sans_ext(sampleNames)  # Remove .tsv.gz

ArrowFiles <- createArrowFiles(
  inputFiles = fragmentFiles,
  sampleNames = sampleNames,
  minTSS = 5,  # 
  minFrags = 1000,  # 
  addTileMat = TRUE,
  addGeneScoreMat = TRUE,
  force = TRUE,
  threads = 1
)

ArrowFiles <- list.files(outputFolder, pattern = ".arrow$", full.names = TRUE)


doubScores <- addDoubletScores(
    input = ArrowFiles,
    k = 10, 
    knnMethod = "UMAP",
    LSIMethod = 1,
    threads = 1,
    outDir = outputFolder,
    logFile = createLogFile("addDoubletScores")
)

proj <- ArchRProject(
  ArrowFiles = ArrowFiles, 
  outputDirectory = outputFolder,
  copyArrows = FALSE,
  threads = 1
)
```

```{r}
p1 <- plotGroups(
    ArchRProj = proj, 
    groupBy = "Sample", 
    colorBy = "cellColData", 
    name = "TSSEnrichment",
    plotAs = "ridges",
    threads = 1
   )

p2 <- plotGroups(
    ArchRProj = proj, 
    groupBy = "Sample", 
    colorBy = "cellColData", 
    name = "TSSEnrichment",
    plotAs = "violin",
    alpha = 0.4,
    addBoxPlot = TRUE,
    threads = 1
   )

plotPDF(p1,p2, name = "QC-Sample-Statistics.pdf", ArchRProj = proj, addDOC = FALSE, width = 10, height = 10)

p3 <- plotFragmentSizes(ArchRProj = proj, threads = 1)
p4 <- plotTSSEnrichment(ArchRProj = proj, threads = 1)

plotPDF(p3,p4, name = "QC-Sample-FragSizes-TSSProfile.pdf", ArchRProj = proj, addDOC = FALSE, width = 10, height = 10)
```

```{r}
saveArchRProject(ArchRProj = proj, outputDirectory = outputFolder, load = FALSE)
```

```{r}
proj <- loadArchRProject(path = outputFolder, force = FALSE, showLogo = TRUE)

proj <- filterDoublets(proj)

proj <- addIterativeLSI(
    ArchRProj = proj,
    useMatrix = "TileMatrix", 
    name = "IterativeLSI", 
    iterations = 2,
    varFeatures = 50000, 
    dimsToUse = 1:25,
    outDir = paste0(outputFolder, "/LSI"),
    threads = 1,
    verbose = TRUE
)

proj <- addHarmony(
    ArchRProj = proj,
    reducedDims = "IterativeLSI",
    name = "Harmony",
    groupBy = "Sample"
)

proj <- addClusters(
    input = proj,
    reducedDims = "IterativeLSI",
    method = "Seurat",
    name = "Clusters",
    resolution = 0.8,
    force = TRUE
    
)

proj <- addUMAP(
    ArchRProj = proj, 
    reducedDims = "IterativeLSI", 
    name = "UMAP", 
    nNeighbors = 30, 
    minDist = 0.5, 
    metric = "cosine",
    threads = 1,
    force = TRUE
)
```

```{r}
p5 <- plotEmbedding(ArchRProj = proj, colorBy = "cellColData", name = "Sample", embedding = "UMAP", threads = 1)
p6 <- plotEmbedding(ArchRProj = proj, colorBy = "cellColData", name = "Clusters", embedding = "UMAP", threads = 1)
ggAlignPlots(p5, p6, type = "h")

plotPDF(p5,p6, name = "Plot-UMAP-Sample-Clusters.pdf", ArchRProj = proj, addDOC = FALSE, width = 5, height = 5)
```

```{r}
proj <- addUMAP(
    ArchRProj = proj, 
    reducedDims = "Harmony", 
    name = "UMAPHarmony", 
    nNeighbors = 30, 
    minDist = 0.5, 
    metric = "cosine",
    threads = 1
)

p7 <- plotEmbedding(ArchRProj = proj, colorBy = "cellColData", name = "Sample", embedding = "UMAPHarmony", threads = 1)
p8 <- plotEmbedding(ArchRProj = proj, colorBy = "cellColData", name = "Clusters", embedding = "UMAPHarmony", threads = 1)

ggAlignPlots(p7, p8, type = "h")
plotPDF(p7,p8, name = "Plot-UMAP2Harmony-Sample-Clusters.pdf", ArchRProj = proj, addDOC = FALSE, width = 5, height = 5)
```


```{r}
proj <- addGroupCoverages(ArchRProj = proj, groupBy = "Clusters", threads = 1)

proj <- addReproduciblePeakSet(
    ArchRProj = proj, 
    groupBy = "Clusters", 
    pathToMacs2 = pathToMacs2,
    threads = 1
)

proj_peakset <- getPeakSet(proj)

proj_peak <- addPeakMatrix(proj, threads = 1)

getAvailableMatrices(proj)
```

```{r}
peak_matrix <- getMatrixFromProject(
  ArchRProj = proj_peak,
  useMatrix = "PeakMatrix",
  binarize = FALSE,
  thread = 1
)

# Get peak ranges
peak_ranges <- rowRanges(peak_matrix)

# Create peak coordinates in the required format
peak_coords <- paste0(
  seqnames(peak_ranges), "_",
  start(peak_ranges), "_",
  end(peak_ranges)
)

# Convert sparse matrix to data frame
peak_df <- as.data.frame(as.matrix(assay(peak_matrix)))

# Reshape the data frame to long format
peak_long <- data.table(
  peak = rep(peak_coords, ncol(peak_df)),
  cell = rep(colnames(peak_df), each = nrow(peak_df)),
  count = as.integer(as.matrix(peak_df))
)

# Remove rows with zero counts
peak_long <- peak_long[count > 0]
```
